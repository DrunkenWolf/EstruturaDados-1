#include"Arvore.h"

void define(tree t) // "inicializa a árvore como vazia - nó raiz vazio
{
    t = NULL;
}

void cria_raiz(tree t, tipo_elem item) // reserva memória para o nó raiz e configura as definições iniciais da árvore
{
    pno no = malloc(sizeof(NO));
    no->esq = NULL;
    no->dir = NULL;
    no->info = item;
    t = no;
}

int altura(tree r) // calcula a altura de uma árvore - recursivamente
{
    if (r == NULL) // se não possui elementos, possui altura 0
    {
        return 0;
    }
    int altE = altura(r->esq); // chamada para cálculo da altura da subárvore à esquerda
    int altD = altura(r->dir); // chamada para cálculo da altura da subárvore à direita
    if (altE > altD) // como a altura da árvore é definida pela nó de maior altura pertencente à árvore, o maior valor (esquerda ou direita) é retornado
    {
        return altE + 1; // soma-se 1 ao valor por considerar um nó NULL como altura 0
    }
    return altD + 1;
}

int numeroNos(tree r) // calcula quantos nós uma árvore possui - recursivamente
{
    if (r == NULL) // se o nó não existe, equivale à 0
    {
        return 0;
    }
    int nE = numeroNos(r->esq); // calcula quantos nós existem à esquerda
    int nR = numeroNos(r->dir); // calcula quantos nós existem à direita
    return nE + nR + 1; // soma-se a quantidade de nós à direita e esquerda e soma-se 1 para correção de nó NULL = 0
}

pno busca (tree raiz, tipo_elem valor) // busca de um valor na árvore - recursivamente
{
    if (raiz == NULL) // quando não há nó, não há valor
    {
        return NULL;
    }
    if (raiz->info == valor) // valor encontrado, retorna-se o próprio nó
    {
        return raiz;
    }
    if (valor < raiz->info) // se for menor, busca-se na subárvore à esquerda. Senão, busca-se à direita
    {
        return busca(raiz->esq, valor);
    }
    else
    {
        return busca(raiz->esq, valor);
    }
}

pno busca_insere(tipo_elem x, tree raiz) // realiza a inserção de um elemento na árvore, mas também realiza busca caso o elemento já exista
{
    if (raiz == NULL) // se não existir elemento, cria-se e o insere como nessa posição - raiz da árvore ou subárvore
    {
        raiz = malloc(sizeof(tree));
        raiz->info = x;
        raiz->esq = NULL;
        raiz->dir = NULL;
        return raiz;
    }
    if (x < raiz->info) // se o valor for menor, será inserido na subárvore à esquerda
    {
        return busca_insere(x, raiz->esq);
    }
    if (x > raiz->info) // se o valor for maior, será inserido na subárvore à direita
    {
        return busca_insere(x, raiz->dir);
    }
    return raiz; // se o elemento a ser inserido já estiver na árvore, apenas retorna-se seu endereço
}
